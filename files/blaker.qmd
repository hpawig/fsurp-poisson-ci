---
title: "Blaker's method"
author: "Hannah Pawig"
format: html
editor: visual
---

```{r load}
#| message: false
#| echo: false

library(tidyverse)
```

## function to calculate mtp

```{r}
# calculate MTP for Poisson rvs
get_mtp <- function(x, lambda) {
  if (x != 0) {
    return(# general case
      min(ppois(x, lambda), # P(X<=x)
          (1-ppois(x-1, lambda)))  # P(X >= x)
      ) 
  } else {
    return(
      min(ppois(0, lambda), 1) # P(X >= 0) = 1 always
    ) 
  }
}
```

# main function

-   Blaker's method involves:

    -   find min tail probability (MTP) of observed x

    -   Fix theta; for all x, find MTPs that are as small or smaller than observed MTP and put those x's in $A_\theta$

    -   observed $x \in A_\theta$ if $P(X \in A_\theta) > \alpha$. Record $\theta$

```{r}
blaker_CI <- function(x, conf.level = 0.95, digits = 3) {
  # set up
  x0 <- seq(from = 0, to = x*10, by = 1)
  alpha <- 1 - conf.level
  lambda <- seq(0, x*10, 1*10^(-digits))
  AS <- c() # initialize acceptance set vec
  p_lambda <- c() # will be used to store all lambda s.t. x in AS_lambda (*plausible* lambdas)
  
  for (i in 1:length(lambda)) {
    AS <- c() # initialize acceptance set vec for lambda[i]
    
    # calculate obs mtp for current lambda
      obs_mtp <- get_mtp(x, lambda[i])
      
      # find all x's with MTP <= observed mtp
      for (j in 1:length(x0)) {
        temp_mtp <- get_mtp(x0[j], lambda[i]) 
        if (temp_mtp <= obs_mtp) {
          AS <- c(AS, x0[j]) # AS will contain all x's resulting in MTP <= obs_mtp at current lambda
          
        # x's in acceptance sets MUST be consecutive. 
        # so stop calculating mtp for x0 
        # after first x0>x has greater mtp
        } else if ((x0[j+1] > x) && (get_mtp(x0[j+1], lambda[i]) > obs_mtp)) { 
          break
        }
      }
      
      # calculate probability of X being in acceptance set
      prob <- sum(dpois(AS[1]:AS[length(AS)], lambda = lambda[i]))
      
      # determine if obs x is in AS for current theta[i] by comparing to alpha
      if (prob > alpha) {
        p_lambda <- c(p_lambda, lambda[i])
      }
  }
  
  lower <- min(p_lambda)
  upper <- max(p_lambda)
  return(data.frame(x,lower,upper))
}


```

### testing

```{r}
blaker_CI(x=13, d=3)

blaker_CI(x=15, d=3)
```
