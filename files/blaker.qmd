---
title: "Blaker's method"
author: "Hannah Pawig"
format: html
editor: visual
---

```{r load}
#| message: false
#| echo: false

library(tidyverse)
```

## function to calculate mtp

```{r}
# calculate MTP for Poisson rvs
get_mtp <- function(x, lambda) {
  if (x != 0) {
    return(# general case
      min(ppois(x, lambda), # P(X<=x)
          (1-ppois(x-1, lambda)))  # P(X >= x)
      ) 
  } else {
    return(
      min(ppois(0, lambda), 1) # P(X >= 0) = 1 always
    ) 
  }
}
```

# main function

-   Blaker's method involves:

    -   find min tail probability (MTP) of observed x

    -   Fix theta; for all x, find MTPs that are as small or smaller than observed MTP and put those x's in $A_\theta$

    -   observed $x \in A_\theta$ if $P(X \in A_\theta) > \alpha$. Record $\theta$

```{r}
# Process
# 1) find min tail probability (MTP) of observed x
# 2) Fix lambda; for all x, find MTPs that are as small or smaller than observed MTP at that lambda. The observed x is always among these
# 3) observed x is in acceptance set of lambda if P(x in A_lambda) > alpha. Record all lambdas
# 4) lower and upper confidence limits given obs.x are smallest and largest lambdas
#   that have acceptance sets with obs. x , respectively


blaker_CI <- function(x, conf.level = 0.95, digits = 2) {
  # set up
  x0 <- seq(from = 0, to = x*5, by = 1)
  alpha <- 1 - conf.level
  lambda <- seq(0, x*5, 1*10^(-digits))
  p_lambda <- c() # will be used to store all lambda s.t. x in AS_lambda (*plausible* lambdas)
  
  for (i in 1:length(lambda)) {
    AS <- c() # initialize acceptance set vec for lambda[i]
    
    # calculate obs mtp for current lambda
      obs_mtp <- get_mtp(x, lambda[i])
      
      # find all x's with MTP <= observed mtp
      for (j in 1:length(x0)) {
        temp_mtp <- get_mtp(x0[j], lambda[i]) 
        if (temp_mtp <= obs_mtp) {
          # AS will contain all x's resulting in MTP <= obs_mtp at current lambda
          AS <- c(AS, x0[j]) 
        
        } else {  
         # current x0 has mtp above observed mtp, so stop checking more x's
          break
        }
      }
    
      # calculate probability of X being in acceptance set
      if (0 %in% AS) {
        prob <- ppois(max(AS), lambda[i])
      } else if (length(AS) > 0) {
        prob <- ppois(max(AS), lambda[i]) - ppois(min(AS)-1, lambda[i])
      } else {
        prob <- 0
      }
      
      # determine if obs x is in AS for current theta[i] by comparing to alpha
      if (prob > alpha) {
        p_lambda <- c(p_lambda, lambda[i])
      }
  }
  
  lower <- min(p_lambda)
  upper <- max(p_lambda)
  return(data.frame(x,lower,upper))
}
```

## CPF Graph for Blaker's method

### function to calculate coverage probability using Blaker's method

```{r}
# creating a coverage probability function given one lambda for B method
blaker_CP <- function(max_lambda, conf.level = 0.95) {

  lambda_vec <- seq(0, max_lambda, 0.25)
  coverages_B <- c() # this vector will contain all coverage probabilities for each lambda in lambda_vec
  
  
  for (i in 1:length(lambda_vec)) {
    captured <- c() # initialize vector that keeps x's which produce CIs that capture current lambda
    p <- 0
    for (x in 0:50) {
      CI_temp <- blaker_CI(x, conf.level, digits = 3)
    
      # sum pmf of each x that captures lambda in its CI
      if (dplyr::between(lambda[i], CI_temp$lower, CI_temp$upper) == TRUE) {
        p <- p + dpois(x, lambda = lambda[i])
      }
    }
    print(p)
    coverages_B <- c(coverages_B, p) # add coverage prob to its corresponding vector
  }
    

  
 # this is the coverage probability for lambda
  return(data.frame(lambda = lambda_vec, 
                    cov.prob = coverages_B))
}



coverage_table_B <- blaker_CP(max_lambda = 50, 0.95)
```

## plot

```{r}
# plot lambda vs. coverage probability
coverage_table_B |> 
  ggplot(mapping = aes(x = lambda, # specify x and y variables
                       y = coverages_B)) +
  
  # specify it is a line graph
  geom_line() +
  
  # define the confidence level line
  geom_line(y = 0.95, col = "red", linetype = "dashed") +
  
  # creating axis labels and plot titles
  labs(x = expression(lambda),
       y = "Coverage Probability",
       title = "Coverage Probability for Blaker's Method",
       subtitle = "for values of the Poisson mean parameter up to 50") +
  
  # label for the confidence level line
  annotate("text", x = 53, y = 0.95, label = "0.95", color = "red") +
  
  # specify x-axis tick breaks
  scale_x_continuous(breaks = seq(0,50,10))
```

```{r}
p <- 0
captured <- 0:2
 for (y in 1:length(captured)) {
      p <- p + dpois(x = captured[y], lambda = lambda[i]) # will eventually sum up to the total cov.prob 
      }
```
