---
title: "Crow-Gardner Method"
format: html
editor: visual
---

```{r}
#| echo: false
#| message: false
library(tidyverse)
```

## AC max coord function

```{r}
# given AC a-b, this function calculates the maximum's coordinates: (lambda, max-prob)
AC_max_coords <- function(a,b) {
   # using prop 2.2a formula. 
  lambda <- prod(a:b)^(1/(b-a+1)) #prop 2.2a
  
  if (a == 0) {
    max_prob <- ppois(b, lambda) # special case of calculating cdf when a is 0
  } else {
    max_prob <- ppois(b, lambda) - ppois(a-1, lambda)
    # general formula
  }
  
  return(data.frame(lambda, max_prob))
}


```

## 

## test coverage function

```{r}
test_coverage <- function(A,B, conf.level) {
  
   # this is maximum prob for current cardinality curve

    max_prob <- AC_max_coords(A, B)$max_prob
  
    # cases to decide how to change a-b: look at if max is above conf level
    
    if (max_prob > conf.level) {
      
      
      
        return(TRUE)
    
      } else {
      
      return(FALSE)
    }
}
```

## main function

```{r}
# K = largest number of x to create a CI for.
CG <- function(K, conf.level, all = FALSE) {
  x <- c(0:K)

  # initialize necessary vectors
  lower <- c()
  upper <- c()

  # step 1  
  a <- 0 # starting a
  b <- 0 # starting b
  lower[1] <- 0



   while (a < (K+1)) {

    # this creates the current curve's function so we can find its root.    
    f <- function(lambda) { 
            if (b != 0) {
              return((ppois(b, lambda) - ppois(a-1, lambda)) - conf.level)
            } else {
              return(ppois(b, lambda) - conf.level)
            }
        }  

 
    
    # this loop finds interval (start,end) to search for where current a-b goes below conf.level
     start <- AC_max_coords(a, b)$lambda # start searching at current a-b's maximum lambda
    a0 <- (a+1); b0 <- (b+1)
     while (sum(dpois(a0:b0,
                      AC_max_coords(a0, b0)$lambda)) >= conf.level) {
      a0 <- a0+1 
      b0 <- b0+1
      } 
     end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda
      
     
     if((test_coverage(a+1, b+1, conf.level) == T)) { # check AC {a+1}-{b+1} first
      a <- a + 1
      b <- b + 1
 
        start <- AC_max_coords(a, b)$lambda # start searching at current a-b's maximum lambda
        a0 <- (a+1); b0 <- (b+1)
        while (sum(dpois(a0:b0,
                         AC_max_coords(a0, b0)$lambda)) >= conf.level) {
          a0 <- a0+1
          b0 <- b0+1
        }
        end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda
             
       # setting coincidental endpoint
       # which will be when the previous AC hits conf.level
        lower[b+1] <- uniroot(f, c(start, end))$root  # current b's lower bound

         start <- AC_max_coords(a-5,b-5)$lambda   #  start search at (a-5)-(b-5) max.
         end <- AC_max_coords(a, b)$lambda # end search at next a-b's maximum lambda

         # a-1's upper bound aka where (a+1)-(b+1) curve starts above CI
          upper[a] <- uniroot(f, c(start,end))$root     
             
 
              
      } else if ((test_coverage(a+1, b+2, conf.level) == F)) { 
        # check next AC by increasing cardinality by 1; ensure {a} non-decreasing
        lower[(b+2)] <- uniroot(f, c(start, end))$root # lower limit for (b+1), aka new b
        b <- b + 1   

        }  else { # if (test_coverage(a+1, b+2, conf.level) == T) {

             start <- AC_max_coords(a, b)$lambda
             a0 <- a + 1; b0 <- b + 1
             end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda

              # setting coincidental endpoint
                
             # identical lower endpoint when AC {a+1}--{b+2} is above conf.level
              lower[b+3] <- uniroot(f, c(start, end))$root  # new b's lower bound
              lower[b+2] <- lower[b+3]  
              upper[a+1] <- lower[b+3]                        # old a's upper bound
              
              
              a <- a + 1
              b <- b + 2

             
           } 
  }
  
  lower <- lower[1:(K+1)]
  upper <- upper[1:(K+1)]
  x <- x[1:(K+1)] # ensuring all vectors are equal in length. 
                          # b/c extra lower endpoints will be cut off


  CIs <- data.frame(x,lower,upper)
  
  # all=TRUE represents display all intervals from x=0 to x=observed/user input
  # use filter to keep rows of the data set "CI" where x = observed (K) and discards those where x != K
  # to get only 1 row for observed x's CI
  if (all == FALSE) {
    CIs <- CIs |> 
      filter(x == K)
  }
  return(CIs)
}
```

\

```{r}
# code to graph a specific AC for troubleshooting

# CG function was having issues in uniroot() when trying to get upper bound for x = 22.
# Looking at AC 23-45, 22-44, and 21-43 to see where we should be searching to 
# avoid uniroot() error.

plot(y = ppois(45, seq(30,34,0.0001))-ppois(22,seq(30,34,0.0001)), x = seq(30,34, by = 0.0001), # AC 23-45
               type = "l", xlim = c(30,40), ylim = c(0.90,1), col = "pink",
     xlab = expression(lambda),
     ylab = "Coverage Probability",
     main = expression("Poisson("~lambda~")"))

# lines(y = (ppois(44, seq(30, 34, by = 0.0001)) - ppois(21, seq(30,34,0.0001))), # AC 22-44
#       x = seq(30, 34, by = 0.0001), type = "l")
lines(y = (ppois(43, seq(30, 34, by = 0.0001)) - ppois(20, seq(30,34,0.0001))), # AC 21-43
      x = seq(30, 34, by = 0.0001), type = "l")

# abline(v=3.764351, col="blue")
 abline(v = 32.315, col = "red")
  abline(v = 33.33612, col = "red") 
abline(h = 0.95, col = "red")


# AC_max_coords(22,44)
# AC_max_coords(23,45)
```

## graph CPF

```{r}
cov_prob_CG <- function(lambda, conf.level) {
  
  
  captured <- c() # initialize
  
    for (x in 0:100) {
      CI_temp <- CG(x, conf.level, all = F)
    
      if (dplyr::between(lambda, CI_temp$lower, CI_temp$upper)) {
        captured <- c(captured,x)
      }
    }
    
  # sum pmf of each x that captures lambda in its CI
   p <- 0
    for (y in 1:length(captured)) {
      p <- p + dpois(captured[y], lambda=lambda)

    }
  
 # this is the coverage probability for lambda
  return(p)
}


```

```{r}
lambda <- c(seq(0, 50, by = 0.05))
coverage <- c()

for (i in (1:length(lambda))) {
  coverage[i] <- cov_prob_CG(lambda = lambda[i], conf.level = 0.95)
}
coverage_table <- data.frame(lambda, coverage)

coverage_table |> 
  ggplot(mapping = aes(x = lambda,
                       y = coverage)) +
  geom_line() +
  geom_line(y = 0.95, col = "red", linetype = "dashed") +
  labs(x = expression(lambda),
       y = "Coverage Probability",
       title = "Coverage Probability for Crow & Gardner's Method",
       subtitle = "for values of the Poisson mean parameter up to 50") +
  annotate("text", x = 53, y = 0.95, label = "0.95", color = "red") +
  scale_x_continuous(breaks = seq(0,50,10)) +
  scale_y_continuous(limits = c(0.94,1.0))
```
