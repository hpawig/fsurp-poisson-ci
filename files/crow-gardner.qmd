---
title: "Crow-Gardner Method"
format: html
editor: visual
---

```{r}
#| echo: false
#| message: false
library(tidyverse)
```

## AC max coord function

```{r}
# given AC a-b, this function calculates the maximum's coordinates: (lambda, max-prob)
AC_max_coords <- function(a,b) {
   # using prop 2.2a formula. 
  lambda <- prod(a:b)^(1/(b-a+1)) #prop 2.2a
  
  if (a == 0) {
    max_prob <- ppois(b, lambda) # special case of calculating cdf when a is 0
  } else {
    max_prob <- ppois(b, lambda) - ppois(a-1, lambda)
    # general formula
  }
  
  return(data.frame(lambda, max_prob))
}


```

## 

## test coverage function

```{r}
test_coverage <- function(A,B, conf.level) {
  
   # this is maximum prob for current cardinality curve

    max_prob <- AC_max_coords(A, B)$max_prob
  
    # cases to decide how to change a-b: look at if max is above conf level
    
    if (max_prob > conf.level) {
      
      
      
        return(TRUE)
    
      } else {
      
      return(FALSE)
    }
}
```

## main function

```{r}
# K = largest number of x to create a CI for.
CG <- function(K, conf.level, all = FALSE) {
  x <- c(0:K)

  # initialize necessary vectors
  lower <- c()
  upper <- c()

  # step 1  
  a <- 0 # starting a
  b <- 0 # starting b
  lower[1] <- 0



   while (a < (K+1)) {

    # this creates the current curve's function so we can find its root.    
    f <- function(lambda) { 
            if (b != 0) {
              return((ppois(b, lambda) - ppois(a-1, lambda)) - conf.level)
            } else {
              return(ppois(b, lambda) - conf.level)
            }
        }  

 
    
    # this loop finds interval (start,end) to search for where current a-b goes below conf.level
     start <- AC_max_coords(a, b)$lambda # start searching at current a-b's maximum lambda
    a0 <- (a+1); b0 <- (b+1)
     while (sum(dpois(a0:b0,
                      AC_max_coords(a0, b0)$lambda)) >= conf.level) {
      a0 <- a0+1 
      b0 <- b0+1
      } 
     end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda
      
     
     if((test_coverage(a+1, b+1, conf.level) == T)) { # check AC {a+1}-{b+1} first
       
       print("case 1"); print("current a-b"); print(c(a,b))


             
       # setting coincidental endpoints
        # current b's lower bound where (a+1)-(b+1) rises above conf.level
        lower[b+1] <- find_roots(a,b,conf.level)$root1  
        
         # a-1's upper bound is also where (a+1)-(b+1) curve comes above CI
          upper[a] <- lower[b+1]     
      
      a <- a + 1
      b <- b + 1          
 
        # check next AC by increasing cardinality by 1; ensure {a} non-decreasing       
      } else if ((test_coverage(a+1, b+2, conf.level) == F)) { 
        print("case 2");print("current a-b")
          print(c(a,b))
       
        lower[(b+2)] <- uniroot(f, c(start, end))$root # lower limit for (b+1), aka new b
        b <- b + 1   

        }  else if (test_coverage(a+1, b+2, conf.level) == T) {
          print("case 3")
          print("current a-b")
          print(c(a,b))
          # setting coincidental endpoint

          # identical lower endpoint when AC {a+1}--{b+2} is above conf.level
          lower[(b+2)+1] <- find_roots(a,b,conf.level)$root1 # b+2's lower bound
          lower[(b+1)+1] <- lower[b+3]  # b+1's lower bound
          upper[a] <- lower[b+3]  # a's upper bound
          
          a <- a + 1
          b <- b + 2

             
           } 
  }
  
  lower <- lower[1:(K+1)]
  upper <- upper[1:(K+1)]
  x <- x[1:(K+1)] # ensuring all vectors are equal in length. 
                          # b/c extra lower endpoints will be cut off


  CIs <- data.frame(x,lower,upper)
  
  # all=TRUE represents display all intervals from x=0 to x=observed/user input
  # use filter to keep rows of the data set "CI" where x = observed (K) and discards those where x != K
  # to get only 1 row for observed x's CI
  if (all == FALSE) {
    CIs <- CIs |> 
      filter(x == K)
  }
  return(CIs)
}


# Example
CIs <- CG(22,0.95,T); CIs
```

\

```{r}
# code to graph a specific AC for troubleshooting

# CG function was having issues in uniroot() when trying to get upper bound for x = 22.
# Looking at AC 23-45, 22-44, and 21-43 to see where we should be searching to 
# avoid uniroot() error.

plot(y = ppois(45, seq(30,34,0.0001))-ppois(22,seq(30,34,0.0001)), x = seq(30,34, by = 0.0001), # AC 23-45
               type = "l", xlim = c(30,40), ylim = c(0.90,1), col = "pink",
     xlab = expression(lambda),
     ylab = "Coverage Probability",
     main = expression("Poisson("~lambda~")"))

# lines(y = (ppois(44, seq(30, 34, by = 0.0001)) - ppois(21, seq(30,34,0.0001))), # AC 22-44
#       x = seq(30, 34, by = 0.0001), type = "l")
lines(y = (ppois(43, seq(30, 34, by = 0.0001)) - ppois(20, seq(30,34,0.0001))), # AC 21-43
      x = seq(30, 34, by = 0.0001), type = "l")

# abline(v=3.764351, col="blue")
 abline(v = 32.315, col = "red")
  abline(v = 33.33612, col = "red") 
abline(h = 0.95, col = "red")


# AC_max_coords(22,44)
# AC_max_coords(23,45)
```

```{r}
# looking at 0-6
plot(y = ppois(6, seq(0,10,0.0001)), x = seq(0,10, by = 0.0001), # AC 0-6
               type = "l", xlim = c(0,10), ylim = c(0.90,1), col = "pink",
     xlab = expression(lambda),
     ylab = "Coverage Probability",
     main = expression("Poisson("~lambda~")"))


abline(h = 0.95, col = "red")
abline(v = find_roots(0,5,0.95), col = "purple") # this is lower(6)
abline(v = find_roots(7,21,0.95), col = "purple") # this is upper(6)


find_roots(7,21,0.95)
find_roots(1,9,0.95)
```

## graph CPF

```{r}
cov_prob_CG <- function(lambda, conf.level) {
  
  
  captured <- c() # initialize
  
    for (x in 0:100) {
      CI_temp <- CG(x, conf.level, all = F)
    
      if (dplyr::between(lambda, CI_temp$lower, CI_temp$upper)) {
        captured <- c(captured,x)
      }
    }
    
  # sum pmf of each x that captures lambda in its CI
   p <- 0
    for (y in 1:length(captured)) {
      p <- p + dpois(captured[y], lambda=lambda)

    }
  
 # this is the coverage probability for lambda
  return(p)
}


```

```{r}
lambda <- c(seq(0, 50, by = 0.05))
coverages_CG <- c()

for (i in (1:length(lambda))) {
  coverages_CG[i] <- cov_prob_CG(lambda = lambda[i], conf.level = 0.95)
}
coverage_table_CG <- data.frame(lambda, coverages_CG)


```

```{r}
# plot lambda vs. coverage probability
coverage_table_CG |> 
  ggplot(mapping = aes(x = lambda, # specify x and y variables
                       y = coverages_CG)) +
  
  # specify it is a line graph
  geom_line() +
  
  # define the confidence level line
  geom_line(y = 0.95, col = "red", linetype = "dashed") +
  
  # creating axis labels and plot titles
  labs(x = expression(lambda),
       y = "Coverage Probability",
       title = "Coverage Probability for Crow & Gardner's Method",
       subtitle = "for values of the Poisson mean parameter up to 50") +
  
  # label for the confidence level line
  annotate("text", x = 53, y = 0.95, label = "0.95", color = "red") +
  
  # specify x-axis tick breaks
  scale_x_continuous(breaks = seq(0,50,10)) +
  
  # show graph from y = 0.94 to y = 1.0
  scale_y_continuous(limits = c(0.94,1.0))
```
