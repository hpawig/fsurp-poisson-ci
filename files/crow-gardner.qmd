---
title: "Crow-Gardner Method"
format: html
editor: visual
---

```{r}
#| echo: false
#| message: false
library(tidyverse)
```

## AC max coord function

```{r}
# given AC a-b, this function calculates the maximum's coordinates: (lambda, max-prob)
AC_max_coords <- function(a,b) {
   # using prop 2.2a formula. 
  lambda <- prod(a:b)^(1/(b-a+1)) #prop 2.2a
  
  if (a == 0) {
    max_prob <- ppois(b, lambda) # special case of calculating cdf when a is 0
  } else {
    max_prob <- ppois(b, lambda) - ppois(a-1, lambda)
    # general formula
  }
  
  return(data.frame(lambda, max_prob))
}


```

## 

## test coverage function

```{r}
test_coverage <- function(A,B, conf.level) {
  
   # this is maximum prob for current cardinality curve

    max_prob <- AC_max_coords(A, B)$max_prob
  
    # cases to decide how to change a-b: look at if max is above conf level
    
    if (max_prob > conf.level) {
      
      
      
        return(TRUE)
    
      } else {
      
      return(FALSE)
    }
}
```

\
\
main function

```{r}
# K = largest number of x to create a CI for.
CG <- function(K, conf.level = 0.95, digits = 3) {
  x <- c(0:K)

  # initialize necessary vectors
  lower <- c()
  upper <- c()

  # step 1  
  a <- 0 # starting a
  b <- 0 # starting b
  lower[1] <- 0



   while (a < (K+1)) {


    # this creates the current curve's function so we can find its root.    
    f <- function(lambda) { 
            if (b != 0) {
              return((ppois(b, lambda) - ppois(a-1, lambda)) - 0.95)
            } else {
              return(ppois(b, lambda) - 0.95)
            }
        }  

 
        if((test_coverage(a+1, b+2, conf.level) != T)) {
             
              
          # this loop finds interval (start,end) to search for current a-b's root
              start <- AC_max_coords(a, b)$lambda # start searching at current a-b's maximum lambda
              a0 <- (a+1); b0 <- (b+1)
                  while (sum(dpois(a0:b0,
                               AC_max_coords(a0, b0)$lambda)) >= conf.level) {
                    a0 <- a0+1 
                    b0 <- b0+1
                  } 
              end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda
      
              
            # there's an "extra" +1 for indexing purposes
              lower[(b+1)+1] <- uniroot(f, c(start, end))$root # lower limit for (b+1), aka new b
              b <- b + 1
            
              print("next curve")
              print(c(a,b))
              print("current b's LB")
              print(lower[b+1])
              
               
           } else if ((test_coverage(a+1, b+1, conf.level) == T)) {
               
                a <- a + 1
                b <- b + 1
                
                print("current curve")
                print(c(a,b))  

              start <- AC_max_coords(a, b)$lambda # start searching at current a-b's maximum lambda
              a0 <- (a+1); b0 <- (b+1)
                  while (sum(dpois(a0:b0,
                               AC_max_coords(a0, b0)$lambda)) >= conf.level) {
                    a0 <- a0+1
                    b0 <- b0+1
                  }
              end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda
      
                
                
                # setting coincidental endpoint
                # which will be when the previous AC hits conf.level
                lower[b+1] <- uniroot(f, c(start, end))$root  # current b's lower bound
                upper[a] <- lower[b+1]                        # a-1's lower bound
            
           } else if (test_coverage(a+1, b+2, conf.level) == T) {
             a <- a + 1
             b <- b + 2
             
            
              # this loop finds interval (start,end) to search for current a-b's root
              start <- AC_max_coords(a, b)$lambda # start searching at current a-b's maximum lambda
                a0 <- (a+1); b0 <- (b+1)
                while (sum(dpois(a0:b0,
                               AC_max_coords(a0, b0)$lambda)) >= conf.level) {
                    a0 <- a0+1
                    b0 <- b0+1
                  }
              end <- AC_max_coords(a0, b0)$lambda # end search at next a-b's maximum lambda
              
              print("current curve!")
              print(c(a,b))  
              
             
                # setting coincidental endpoint
                # which will be when the previous AC hits conf.level
              lower[b+1] <- uniroot(f, c(start, end))$root  # current b's lower bound
              upper[a] <- lower[b+1]                        # a-1's lower bound
              # 
              # if(is.na(lower[b]) != F) {
              #   lower[b] <- lower[b+1]
              # }
              print(paste0("coincidental: ",lower[b]))
             
           } else {
           
         }
  }
  
  
  lower <- lower[1:(K+1)]
  upper <- upper[1:(K+1)]
  x <- x[1:(K+1)] # ensuring all vectors are equal in length. 
                          # b/c extra lower endpoints will be cut off
  
  
  lower <- round(lower, digits)
  upper <- round(upper, digits)
  CIs <- data.frame(x,lower,upper)
  return(CIs)
}
```

```{r}
CG(K=15)
```
